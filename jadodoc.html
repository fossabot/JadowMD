<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hello Bulma!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css">
    <link rel="stylesheet" href="https://unpkg.com/bulmaswatch/flatly/bulmaswatch.min.css">
    <script defer src="https://use.fontawesome.com/releases/v5.0.7/js/all.js"></script>
</head>
<body>
<nav class="navbar" role="navigation" aria-label="main navigation">
    <div class="navbar-start">
        <a class="navbar-item" href="https://bulma.io">
            JadowMD
        </a>

    </div>
</nav>

<section class="main-content columns is-fullheight section">

    <aside class="menu">
        <p class="menu-label">
            List
        </p>
        <ul class="menu-list" id="menu-list">
            <li><a href="#" id="menuItem-hoge" onclick="menuItem('hoge');">hoge</a></li>
            <li><a href="#" id="menuItem-index" onclick="menuItem('index');">index</a></li>
        </ul>
    </aside>

    <div id="injectTarget" class="container column is-10">
    </div>

    </div>
</section>

<template id="hoge">
    <div class="box">
        Table of Contents
        <div class="content">
            <ul><li><a href="#KotlinTest">KotlinTest1</a><ul><li><a href="#How to use">How to use2</a><ul><li><a href="#Gradle">Gradle4</a><ul></ul></li><li><a href="#Maven">Maven4</a><ul></ul></li></ul></li><li><a href="#Testing Styles">Testing Styles2</a><ul></ul></li><li><a href="#Matchers and Assertions">Matchers and Assertions2</a><ul><li><a href="#Custom Matchers">Custom Matchers3</a><ul></ul></li></ul></li><li><a href="#Soft Assertions">Soft Assertions2</a><ul></ul></li><li><a href="#Exceptions">Exceptions2</a><ul></ul></li><li><a href="#Inspectors">Inspectors2</a><ul></ul></li><li><a href="#Listeners">Listeners2</a><ul></ul></li><li><a href="#Project Config">Project Config2</a><ul><li><a href="#Executing Code Before and After a Whole Project">Executing Code Before and After a Whole Project3</a><ul></ul></li><li><a href="#Project Extensions">Project Extensions3</a><ul></ul></li><li><a href="#Parallelism">Parallelism3</a><ul></ul></li><li><a href="#Discovery Extension">Discovery Extension3</a><ul></ul></li></ul></li><li><a href="#Property-based Testing">Property-based Testing2</a><ul><li><a href="#Property Testing">Property Testing3</a><ul></ul></li><li><a href="#Custom Generators">Custom Generators3</a><ul></ul></li></ul></li><li><a href="#Table-driven Testing">Table-driven Testing2</a><ul></ul></li><li><a href="#One Instance Per Test">One Instance Per Test2</a><ul></ul></li><li><a href="#Test Case Config">Test Case Config2</a><ul></ul></li><li><a href="#Disabling Test Cases and Running Test Cases Conditionally">Disabling Test Cases and Running Test Cases Conditionally2</a><ul><li><a href="#By Config">By Config3</a><ul></ul></li><li><a href="#Focus">Focus3</a><ul></ul></li><li><a href="#Bang">Bang3</a><ul></ul></li></ul></li><li><a href="#Grouping Tests with Tags">Grouping Tests with Tags2</a><ul></ul></li><li><a href="#Closing resource automatically">Closing resource automatically2</a><ul></ul></li><li><a href="#Futures">Futures2</a><ul><li><a href="#Eventually">Eventually3</a><ul></ul></li></ul></li><li><a href="#Extensions">Extensions2</a><ul><li><a href="#Arrow">Arrow3</a><ul></ul></li><li><a href="#Spring">Spring3</a><ul><li><a href="#Field Injection">Field Injection4</a><ul></ul></li><li><a href="#Constructor Injection">Constructor Injection4</a><ul></ul></li></ul></li></ul></li></ul></li></ul>
        </div>
    </div>
    <div class="content">
        <div><h1><a id="KotlinTest"></a>KotlinTest</h1><p><a href="http://search.maven.org/#search%7Cga%7C1%7Ckotlintest"><img src="https://img.shields.io/maven-central/v/io.kotlintest/kotlintest-core.svg?label=latest%20release"/></a> <a href=""><img src="https://img.shields.io/github/license/kotlintest/kotlintest.svg" alt="GitHub license" /></a></p><h2><a id="How to use"></a>How to use</h2><p>KotlinTest is published to Maven Central so you can get the latest version from the little badge at the top of the readme.</p><h4><a id="Gradle"></a>Gradle</h4><p>To use in gradle, configure your build to use the <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-build-gradle">JUnit Platform</a>. For Gradle 4.6 and higher this is
 as simple as adding <code>useJUnitPlatform()</code> inside the <code>test</code> block and then adding the KotlinTest dependency.</p><pre><code class="language-groovy">test {
  useJUnitPlatform()
}

dependencies {
  testCompile 'io.kotlintest:kotlintest-runner-junit5:3.1.8'
}
</code></pre><h4><a id="Maven"></a>Maven</h4><p>For maven you must configure the surefire plugin for junit tests.</p><pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.19.1&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.platform&lt;/groupId&gt;
            &lt;artifactId&gt;junit-platform-surefire-provider&lt;/artifactId&gt;
            &lt;version&gt;1.2.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></pre><p>And then add the KotlinTest JUnit5 runner to your build.</p><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.kotlintest&lt;/groupId&gt;
    &lt;artifactId&gt;kotlintest-runner-junit5&lt;/artifactId&gt;
    &lt;version&gt;3.1.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h2><a id="Testing Styles"></a>Testing Styles</h2><p>KotlinTest is permissive in the way you can lay out tests, which it calls a testing <em>style</em>.
There are <a href="styles.md">several styles</a> to pick from. There is no functional difference between these -
 it is simply a matter of preference how you structure your tests. It is common to see several styles in one project.</p><p>You can choose a testing style by extending StringSpec, WordSpec, FunSpec, ShouldSpec, FeatureSpec, BehaviorSpec, FreeSpec, DescribeSpec, or ExpectSpec in your test class,
 and writing your tests either inside an <code>init {}</code> block or inside a lambda parameter in the class constructor.</p><p>For example, using a lambda expression in the constructor, with the StringSpec gives us:</p><pre><code class="language-kotlin">class MyTests : StringSpec({
  // tests here
})
</code></pre><p>And using an init block, again with the StringSpec looks like:</p><pre><code class="language-kotlin">class MyTests : StringSpec() {
  init {
    // tests here
  }
}
</code></pre><p>Using the lambda expression avoids another level of indentation and looks neater,
 but it means you cannot override methods in the parent class such as <code>beforeTest</code> and <code>afterTest</code>.</p><p><a href="styles.md">See an example</a> of each testing style.</p><h2><a id="Matchers and Assertions"></a>Matchers and Assertions</h2><p>Matchers are used to assert a variable or function should have a particular value.
KotlinTest has over 100 built in matchers. Matchers can be used in two styles:</p><ul><li>Extension functions like <code>a.shouldBe(b)</code> or <code>a.shouldStartWith(&quot;foo&quot;)</code></li><li>Infix functions like <code>a shouldBe b</code> or <code>a should startWith(&quot;foo&quot;)</code></li></ul><p>Both styles are supported. The advantage of the extension function style is that the IDE can autocomplete for you,
but some people may prefer the infix style as it is slightly cleaner.</p><p>Matchers can be negated by using <code>shouldNot</code> instead of <code>should</code> for the infix style. For example, <code>a shouldNot startWith(&quot;boo&quot;)</code>.
For the extension function style, each function has an equivalent negated version, for example, <code>a.shouldNotStartWith(&quot;boo&quot;)</code>.</p><p>Matchers are available in the <code>kotlintest-assertions</code> module, which is usually added to the build
when you add a KotlinTest test runner to your build (eg, <code>kotlintest-runner-junit5</code>). Of course, you could always add
this to your build explicitly.</p><p>The simplest matcher is that a value should be equal to something, eg: <code>x.shouldBe(y)</code>.
This will also work for null values, eg <code>x.shouldBe(null)</code>. More specialized matchers test for things like string length, file size,
 collection duplicates and so on.</p><p>See the <a href="matchers.md">full list of matchers</a> for more details.</p><h3><a id="Custom Matchers"></a>Custom Matchers</h3><p>It is easy to add your own matchers. Simply extend the Matcher<T> interface, where T is the type you wish to match against.
The Matcher interface specifies one method, <code>test</code>, which you must implement returning an instance of Result.
The Result contains a boolean to indicate if the test passed or failed, and two messages.</p><p>The first message should always be in the positive, ie, indicate what &quot;should&quot; happen, and the second message
is used when the matcher is used with <em>not</em>.</p><p>For example to create a matcher that checks that a string contains the substring &quot;foo&quot;, we can do the following:</p><pre><code class="language-kotlin">fun containFoo() = object : Matcher&lt;String&gt; {
  override fun test(value: String) = Result(value.contains(&quot;foo&quot;), &quot;String $value should include foo&quot;, &quot;String $value should not include foo&quot;)
}
</code></pre><p>This matcher could then be used as follows:</p><pre><code class="language-kotlin">&quot;hello foo&quot; should containFoo()
&quot;hello bar&quot; shouldNot containFoo()
</code></pre><p>And we should then create an extension function version, like this:</p><pre><code class="language-kotlin">fun String.shouldContainFoo() = this should containFoo()
fun String.shouldNotContainFoo() = this shouldNot containFoo()
</code></pre><h2><a id="Soft Assertions"></a>Soft Assertions</h2><p>Normally, assertions like <code>shouldBe</code> throw an exception when they fail.
But sometimes you want to perform multiple assertions in a test, and
would like to see all of the assertions that failed. KotlinTest provides
the <code>assertSoftly</code> function for this purpose.</p><pre><code class="language-kotlin">assertSoftly {
  foo shouldBe bar
  foo should contain(baz)
}
</code></pre><p>If any assertions inside the block failed, the test will continue to
run. All failures will be reported in a single exception at the end of
the block.</p><h2><a id="Exceptions"></a>Exceptions</h2><p>To assert that a given block of code throws an exception, one can use the <code>shouldThrow</code> function. Eg,</p><pre><code class="language-kotlin">shouldThrow&lt;IllegalAccessException&gt; {
  // code in here that you expect to throw an IllegalAccessException
}
</code></pre><p>You can also check the caught exception:</p><pre><code class="language-kotlin">val exception = shouldThrow&lt;IllegalAccessException&gt; {
  // code in here that you expect to throw an IllegalAccessException
}
exception.message should start with &quot;Something went wrong&quot;
</code></pre><p>If you want to test that <em>exactly</em> a type of exception is thrown, then use <code>shouldThrowExactly&lt;E&gt;</code>.
If you want to test that <em>any</em> exception is thrown, then use <code>shouldThrowAny</code>.</p><h2><a id="Inspectors"></a>Inspectors</h2><p>Inspectors allow us to test elements in a collection. They are extension functions for collections and arrays that test
that all, none or some of the elements pass the given assertions. For example, to test that all elements in a collection
contain an undercore and start with &quot;aa&quot; we could do:</p><pre><code class="language-kotlin">class StringSpecExample : StringSpec({
  &quot;your test case&quot; {
    val xs = listOf(&quot;aa_1&quot;, &quot;aa_2&quot;, &quot;aa_3&quot;)
    xs.forAll {
      it.shouldContain(&quot;_&quot;)
      it.shouldStartWith(&quot;aa&quot;)
    }
  }
})
</code></pre><p>Similarly, if we wanted to asset that <em>no</em> elements in a collection passed the assertions, we can do:</p><pre><code class="language-kotlin">xs.forNone {
  it.shouldContain(&quot;x&quot;)
  it.shouldStartWith(&quot;bb&quot;)
}
</code></pre><p>The full list of inspectors are:</p><ul><li><code>forAll</code> which asserts every element passes the assertions</li><li><code>forNone</code> which asserts no element passes</li><li><code>forOne</code> which asserts only a single element passed</li><li><code>forAtMostOne</code> which asserts that either 0 or 1 elements pass</li><li><code>forAtLeastOne</code> which asserts that 1 or more elements passed</li><li><code>forAtLeast(k)</code> which is a generalization that k or more elements passed</li><li><code>forAtMost(k)</code> which is a generalization that k or fewer elements passed</li><li><code>forAny</code> which is an alias for <code>forAtLeastOne</code></li><li><code>forSome</code> which asserts that between 1 and n-1 elements passed. Ie, if NONE pass or ALL pass then we consider that a failure.</li><li><code>forExactly(k)</code> which is a generalization that exactly k elements passed. This is the basis for the implementation of the other methods</li></ul><h2><a id="Listeners"></a>Listeners</h2><p>It is a common requirement to run setup or teardown code before and after a test, or before and after all tests in a Spec class. Or sometimes
 before and after the entire project. For this KotlinTest provides the <code>TestListener</code> interface. Instances of this interface can be registered
 with a <code>Spec</code> class or project wide by using <a href="#project-config">ProjectConfig</a>.</p><p>This interface contains several functions,
 such as <code>beforeTest</code>, <code>afterTest</code>, <code>beforeSpec</code> and so on, which are used to hook into the lifecycle of the test engine.</p><p>Let's say we want to log the time taken for each test case. We can do this by using the <code>beforeTest</code> and <code>afterTest</code> functions
 as follows:</p><pre><code class="language-kotlin">object TimerListener : TestListener {

  var started = 0L

  override fun beforeTest(description: Description): Unit {
    started = System.currentTimeMillis()
  }

  override fun afterTest(description: Description, result: TestResult): Unit {
    println(&quot;Duration of $description = &quot; + System.currentTimeMillis() - started)
  }
}
</code></pre><p>Then we can register this with a particular Spec, like so:</p><pre><code class="language-kotlin">class MyTestClass : WordSpec() {

  override fun listeners(): List&lt;TestListener&gt; = listOf(TimerListener)

  // tests here

}
</code></pre><p>These functions will now be invoked for every test case inside the <code>MyTestClass</code> test class. Maybe you want
 this listener to run for every test in the entire project. To do that, you would register the listener with
 the project config singleton. For more information on this see <a href="#project-config">ProjectConfig</a>.</p><p>The full list of the functions in the <code>TestListener</code> interface is as follows:</p><table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody><tr><td>beforeTest</td><td>This function will be invoked each time a new Test Case is executed.</td></tr><tr class="intellij-row-even"><td>afterTest</td><td>Is invoked when a Test Case has finished. This includes when a test case is ignored (skipped), passes (is successful), or fails (errors).</td></tr><tr><td>beforeSpec</td><td>Is invoked each time a Spec is started, before any <code>beforeTest</code> functions are invoked.</td></tr><tr class="intellij-row-even"><td>afterSpec</td><td>Is invoked each time a Spec completes, after all <code>afterTest</code> functions are invoked.</td></tr><tr><td>beforeProject</td><td>Is invoked as soon as the Test Engine is started.</td></tr><tr class="intellij-row-even"><td>afterProject</td><td>Is invoked as soon as the Test Engine has finished.</td></tr><tr><td>afterDiscovery</td><td>Is invoked after all the Spec classes have been discovered, but before any <code>beforeSpec</code> functions are called, and before any specs are instantiated by the Test Engine.</td></tr></tbody></table><h2><a id="Project Config"></a>Project Config</h2><p>KotlinTest is flexible and has many ways to configure tests.
 Project-wide configuration is used by creating a special singleton object
 which is loaded at runtime by KotlinTest.</p><p>To do this, create an object that is derived from <code>AbstractProjectConfig</code>, name this object <code>ProjectConfig</code>
and place it in a package called <code>io.kotlintest.provided</code>. KotlinTest will detect it's presence and use any configuration
defined there when executing tests.</p><p>Some of the configuration available in <code>ProjectConfig</code> includes parallelism of tests, executing code before and after
 all tests, and re-usable listeners or extensions.</p><h3><a id="Executing Code Before and After a Whole Project"></a>Executing Code Before and After a Whole Project</h3><p>To execute some logic before the very first test case and/or after the very last test case of your project, you can
 override <code>beforeAll</code> and <code>afterAll</code> in the <code>ProjectConfig</code> singleton.</p><p>Example:</p><pre><code class="language-kotlin">package io.kotlintest.provided

object ProjectConfig : AbstractProjectConfig() {

  private var started: Long = 0

  override fun beforeAll() {
    started = System.currentTimeMillis()
  }

  override fun afterAll() {
    val time = System.currentTimeMillis() - started
    println(&quot;overall time [ms]: &quot; + time)
  }
}
</code></pre><h3><a id="Project Extensions"></a>Project Extensions</h3><p><em>(Project Extensions are DEPRECATED in favour of Test Listeners.)</em></p><p>Many types of reusable extensions can be registered in the <code>ProjectConfig</code>. Where appropriate these will be executed for all
 test cases and specs. Test level extensions will be covered in the next section.</p><p>For example, to extract logic for beforeAll and afterAll into a seperate class you can implement the interface <code>ProjectExtension</code>.</p><pre><code class="language-kotlin">class TimerExtension: ProjectExtension {

  private var started: Long = 0

  override fun beforeAll() {
    started = System.currentTimeMillis()
  }

  override fun afterAll() {
    val time = System.currentTimeMillis() - started
    println(&quot;overall time [ms]: &quot; + time)
  }
}
</code></pre><p>This extension can then be registered with the project config.</p><pre><code class="language-kotlin">object ProjectConfig : AbstractProjectConfig() {
  override val extensions = listOf(TimerExtension)
}
</code></pre><h3><a id="Parallelism"></a>Parallelism</h3><p>KotlinTest supports running specs in parallel to take advantage of modern cpus with several cores. To do this, override
 the <code>parallelism</code> function inside the project config.</p><pre><code class="language-kotlin">object ProjectConfig : AbstractProjectConfig() {
   override fun parallelism(): Int = 2
}
</code></pre><p>By default the value is 1, which will run each spec serially.</p><p>Note: Test cases inside each spec will always run sequentially (either in definition order, or in a random order, see documentation on test ordering).</p><h3><a id="Discovery Extension"></a>Discovery Extension</h3><p><em>Advanced Feature</em></p><p>Another type of extension that can be used inside <code>ProjectConfig</code> is the <code>DiscoveryExtension</code>. This extension is designed
 to allow customisation of the way spec classes are discovered and instantiated. There are two functions of interest that
 can be overridden.</p><p>The first is <code>afterScan</code> which accepts a list of Spec classes that were discovered by KotlinTest during the <em>discovery</em> phase
 of the test engine. This function then returns a list of the classes that should actually be instantiated and executed. By
 overriding this function, you are able to filter which classes are used, or even add in extra classes not originally discovered.</p><p>The second function is <code>instantiate</code> which accepts a <code>KClass&lt;Spec&gt;</code> and then attempts to create an instance of this Spec class in order
 to then run the test cases defined in it. By default, Spec classes are assumed to have a zero-arg primary constructor.
 If you wish to use non-zero arg primary constructors this function can be implemented with logic on how to instantiate a test class.</p><p>An implementation can choose to create a new instance, or it can choose to return null if it wishes to pass control to the next
extension (or if no more extensions, then back to the Test Engine itself).</p><p>By overriding this function, extensions are able to customize the way classes are created, to support things like constructors
with parameters, or classes that require special initialization logic. This type of extension is how the Spring Constructor Injection
add-on works for example.</p><h2><a id="Property-based Testing"></a>Property-based Testing <a name="property-based"></a></h2><h3><a id="Property Testing"></a>Property Testing</h3><p>To automatically test your code with many combinations of values, you can allow KotlinTest to do the boilerplate
by using property testing with <code>generators</code>. You invoke <code>assertAll</code> or <code>assertNone</code> and pass in a lambda, where the lambda
parameters are populated automatically with many different values. The lambda must specify explicitly the parameter
types as KotlinTest will use those to determine what types of values to pass in.</p><p>For example, here is a property test that checks that for any two Strings, the length of <code>a + b</code>
is the same as the length of <code>a</code> plus the length of <code>b</code>. In this example KotlinTest would
execute the test 1000 times for random String combinations.</p><pre><code class="language-kotlin">class PropertyExample: StringSpec() {
  init {

    &quot;String size&quot; {
      assertAll({ a: String, b: String -&gt;
        (a + b).length shouldBe a.length + b.length
      })
    }

  }
}
</code></pre><p>You can also specify the number of times a test is going to be run. Here is the same test but this time it will run 2300 times.</p><pre><code class="language-kotlin">class PropertyExample: StringSpec() {
  init {

    &quot;String size&quot; {
      forAll(2300) { a: String, b: String -&gt;
        (a + b).length == a.length + b.length
      }
    }

  }
}
</code></pre><p>There are generators defined for all the common base types - String, Ints, UUIDs, etc. If you need to generate custom types
then you can simply specify the generator manually (or write your own). For example here is the same test again but
with the generators explicitly specified.</p><pre><code class="language-kotlin">class PropertyExample: StringSpec() {
  init {

    &quot;String size&quot; {
      forAll(Gen.string(), Gen.string(), { a: String, b: String -&gt;
        (a + b).length == a.length + b.length
      })
    }

  }
}
</code></pre><h3><a id="Custom Generators"></a>Custom Generators</h3><p>To write your own generator for a type T, you just implement the interface <code>Gen&lt;T&gt;</code>.</p><pre><code class="language-kotlin">interface Gen&lt;T&gt; {
  fun constants(): Iterable&lt;T&gt;
  fun random(): Sequence&lt;T&gt;
}
</code></pre><p>The first function, <code>constants</code> returns values that should <em>always</em> be included
 in the test inputs. This is typically used for common edge case values. For example, the <code>Int</code> generator implements
 <code>constants</code> to return 0, Int.MIN_VALUE and Int.MAX_VALUE as these are values that are often overlooked.</p><p>The second function is <code>random</code> which returns a lazy list of random values, which is the bread and butter of a generator.</p><p>For example you could write a <code>Gen</code> that supports a custom class called <code>Person</code>.
 In this case there are no real edge case values for a <code>Person</code> instance so we can leave <code>constants</code> as an empty list.</p><pre><code class="language-kotlin">data class Person(val name: String, val age: Int)
class PersonGenerator : Gen&lt;Person&gt; {
    override fun constants() = emptyList&lt;Person&gt;()
    override fun random() = generateSequence {
        Person(Gen.string().random().first(), Gen.int().random().first())
    }
}
</code></pre><h2><a id="Table-driven Testing"></a>Table-driven Testing</h2><p>To test your code with different parameter combinations, you can use a table of values as input for your test
cases. This is sometimes called <em>data driven testing</em> and other times called <em>table driven testing</em>.</p><p>Invoke the <code>forAll</code> or <code>forNone</code> function, passing in one or more <code>row</code> objects, where each row object contains
the values to be used be a single invocation of the test. After the <code>forAll</code> or <code>forNone</code> function, setup your
actual test function to accept the values of each row as parameters.</p><p>The row object accepts any set of types, and the type checker will ensure your types are consistent with the parameter
types in the test function.</p><pre><code class="language-kotlin">&quot;square roots&quot; {
  forall(
      row(2, 4),
      row(3, 9),
      row(4, 16),
      row(5, 25)
  ) { root, square -&gt;
    root * root shouldBe square
  }
}
</code></pre><p>In the above example, the <code>root</code> and <code>square</code> parameters are automatically inferrred to be integers.</p><p>If there is an error for any particular input row, then the test will fail and KotlinTest will automatically
match up each input to the corresponding parameter names. For example, if we change the previous example to include the row <code>row(5,55)</code>
then the test will be marked as a failure with the following erorr message.</p><pre><code>Test failed for (root, 5), (square, 55) with error expected: 55 but was: 25
</code></pre><p>Table testing can be used within any spec. Here is an example using <code>StringSpec</code>.</p><pre><code class="language-kotlin">class StringSpecExample : StringSpec({
  &quot;string concat&quot; {
    forall(
      row(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;abc&quot;),
      row(&quot;hel&quot;, &quot;lo wo&quot;, &quot;rld&quot;, &quot;hello world&quot;),
      row(&quot;&quot;, &quot;z&quot;, &quot;&quot;, &quot;z&quot;)
    ) { a, b, c, d -&gt;
      a + b + c shouldBe d
    }
  }
})
</code></pre><h2><a id="One Instance Per Test"></a>One Instance Per Test</h2><p>All specs allow you to instruct the test engine to create a new instance of the Spec for every test case.</p><p>To do this simply override the <code>isInstancePerTest()</code> function returning true:</p><pre><code class="language-kotlin">class MyTests : FunSpec() {
  override fun isInstancePerTest() = true
  init {
    // tests here
  }
}
</code></pre><p>This style of testing allows variables to be reset for each test. By default <code>isInstancePerTest()</code> returns false.</p><h2><a id="Test Case Config"></a>Test Case Config</h2><p>Each test can be configured with various parameters. After the test name, invoke the config function
 passing in the parameters you wish to set. The available parameters are:</p><ul><li><code>invocations</code> - the number of times to run this test. Useful if you have a non-deterministic test and you want to run that particular test a set number of times. Defaults to 1.</li><li><code>threads</code> - Allows the invocation of this test to be parallelized by setting the number of threads to use in a thread pool executor for this test. If invocations is 1 (the default) then this parameter will have no effect. Similarly, if you set invocations to a value less than or equal to the number threads, then each invocation will have its own thread.</li><li><code>enabled</code> - If set to <code>false</code> then this test is disabled. Can be useful if a test needs to be temporarily ignored. You can also use this parameter with boolean expressions to run a test only under certain conditions.</li><li><code>timeout</code> - sets a timeout for this test. If the test has not finished in that time then the test fails. Useful for code that is non-deterministic and might not finish. Timeout is of type <code>Duration</code> which can be instantiated like <code>2.seconds</code>, <code>3.minutes</code> and so on.</li><li><code>tags</code> - a set of tags that can be used to group tests (see detailed description below).</li></ul><p>Examples of setting config:</p><pre><code class="language-kotlin">class MyTests : ShouldSpec() {
  init {
    should(&quot;return the length of the string&quot;).config(invocations = 10, threads = 2) {
      &quot;sammy&quot;.length shouldBe 5
      &quot;&quot;.length shouldBe 0
    }
  }
}
</code></pre><pre><code class="language-kotlin">class MyTests : WordSpec() {
  init {
    &quot;String.length&quot; should {
      &quot;return the length of the string&quot;.config(timeout = 2.seconds) {
        &quot;sammy&quot;.length shouldBe 5
        &quot;&quot;.length shouldBe 0
      }
    }
  }
}
</code></pre><pre><code class="language-kotlin">class FunSpecTest : FunSpec() {
  init {
    test(&quot;FunSpec should support config syntax&quot;).config(tags = setOf(Database, Linux)) {
      // ...
    }
  }
}
</code></pre><p>You can also specify a default TestCaseConfig for all test cases of a Spec:</p><pre><code class="language-kotlin">class MySpec : StringSpec() {

  override val defaultTestCaseConfig = TestCaseConfig(invocations = 3)

  init {
    // your test cases ...
  }
}
</code></pre><h2><a id="Disabling Test Cases and Running Test Cases Conditionally"></a>Disabling Test Cases and Running Test Cases Conditionally</h2><p>Sometimes we want to temporarily disable some tests in of a test suite.
Perhaps we’re experimenting with some API changes and don’t want to have to keep changing all the tests until we’re happy with the new API.
Or perhaps we’re debugging and want to reduce the noise in the output.</p><p>There are several ways to disable tests.</p><h3><a id="By Config"></a>By Config</h3><p>You can disable a test case simply by setting the config parameter <code>enabled</code> to <code>false</code>.
If you're looking for something like JUnit's <code>@Ignore</code>, this is for you.</p><pre><code class="language-kotlin">&quot;should do something&quot;.config(enabled = false) {
  ...
}
</code></pre><p>You can use the same mechanism to run tests only under certain conditions.
 For example you could run certain tests only on Linux systems using
 <a href="http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/SystemUtils.html#IS_OS_WINDOWS">SystemUtils</a>.IS_OS_LINUX from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.</p><pre><code class="language-kotlin">&quot;should do something&quot;.config(enabled = IS_OS_LINUX) {
  ...
}
</code></pre><p><code>isLinux</code> and <code>isPostgreSQL</code> in the example are just expressions (values, variables, properties, function calls) that evaluate to <code>true</code> or <code>false</code>.</p><h3><a id="Focus"></a>Focus</h3><p>KotlinTest supports isolating a single top level test by preceding the test name with <code>f:</code>.
Then only that test (and any subtests defined inside that scope) will be executed, with the rest being skipped.</p><p>For example, in the following snippet only the middle test will be executed.</p><pre><code class="language-kotlin">class FocusExample : StringSpec({
    &quot;test 1&quot; {
     // this will be skipped
    }

    &quot;f:test 2&quot; {
     // this will be executed
    }

    &quot;test 3&quot; {
     // this will be skipped
    }
})
</code></pre><h3><a id="Bang"></a>Bang</h3><p>The opposite of focus is possible, which is to prefix a test with an exclamation mark <code>!</code> and then that test (and any subtests defined inside that scope) will be skipped.
In the next example we’ve disabled the first test by adding the “!” prefix.</p><pre><code class="language-kotlin">class BangExample : StringSpec({

  &quot;!test 1&quot; {
    // this will be ignored
  }

  &quot;test 2&quot; {
    // this will run
  }

  &quot;test 3&quot; {
    // this will run too
  }
})
</code></pre><h2><a id="Grouping Tests with Tags"></a>Grouping Tests with Tags</h2><p>Sometimes you don't want to run all tests and KotlinTest provides tags to be able to run only
certain tests. Tags are objects inheriting from <code>io.kotlintest.Tag</code>.</p><p>To group tests by operating system you could define the following tags:</p><pre><code class="language-kotlin">object Linux : Tag()
object Windows: Tag()
</code></pre><p>Test cases are marked with tags with the <code>config</code> function:</p><pre><code class="language-kotlin">import io.kotlintest.specs.StringSpec

class MyTest : StringSpec() {
  init {
    &quot;should run on Windows&quot;.config(tags = setOf(Windows)) {
      // ...
    }

    &quot;should run on Linux&quot;.config(tags = setOf(Linux)) {
      // ...
    }

    &quot;should run on Windows and Linux&quot;.config(tags = setOf(Windows, Linux)) {
      // ...
    }
  }
}
</code></pre><p>Then by invoking the test runner with a system property of <code>kotlintest.tags.include</code> and/or <code>kotlintest.tags.exclude</code>, you
can control which tests are run:</p><ul><li>If no <code>kotlintest.tags.include</code> and/or <code>kotlintest.tags.exclude</code> are specified, all tests (both tagged and untagged ones) are run.</li><li>If only <code>kotlintest.tags.include</code> are specified, only tests with that tag are run (untagged test are <em>not</em> run).</li><li>If only <code>kotlintest.tags.exclude</code> are specified, only tests without that tag are run (untagged tests <em>are</em> run).</li><li>If you provide more than one tag for <code>kotlintest.tags.include</code> or <code>kotlintest.tags.exclude</code>, a test case with at least one of the given tags is included/excluded.</li></ul><p>Provide the simple names of tag object (without package) when you run the tests.
Please pay attention to the use of upper case and lower case! If two tag objects have the same simple name (in different name spaces) they are treated as the same tag.</p><p>Example: To run only test tagged with <code>Linux</code>, but not tagged with <code>Database</code>, you would invoke
Gradle like this:</p><pre><code>gradle test -Dkotlintest.tags.include=Linux -Dkotlintest.tags.exclude=Database
</code></pre><p>If you use <code>kotlintest.tags.include</code> and <code>kotlintest.tags.exclude</code> in combination, only the tests tagged with a tag from
<code>kotlintest.tags.include</code> but not tagged with a tag from <code>kotlintest.tags.exclude</code> are run. If you use only <code>kotlintest.tags.exclude</code>
all tests but the tests tagged with the given tags are are run.</p><h2><a id="Closing resource automatically"></a>Closing resource automatically</h2><p>You can let KotlinTest close resources automatically after all tests have been run:</p><pre><code class="language-kotlin">class StringSpecExample : StringSpec() {

  val reader = autoClose(StringReader(&quot;xyz&quot;))

  init {
    &quot;your test case&quot; {
      // use resource reader here
    }
  }
}
</code></pre><p>Resources that should be closed this way must implement <a href="http://docs.oracle.com/javase/6/docs/api/java/io/Closeable.html"><code>java.io.Closeable</code></a>. Closing is performed in
reversed order of declaration after the return of the last spec interceptor.</p><h2><a id="Futures"></a>Futures</h2><p>When testing future based code, it's useful to have a test run as soon as a future has completed, rather than blocking and waiting.
KotlinTest allows you to do this, by using the <code>whenReady(future, fn)</code> construct.</p><pre><code class="language-kotlin">class MyTests : StringSpec({

    &quot;test a future&quot; {
        val f: CompletableFuture&lt;String&gt; = someFuture()
        whenReady(f) {
            it shouldBe &quot;wibble&quot;
        }
    }
})
</code></pre><h3><a id="Eventually"></a>Eventually <a name="eventually"></a></h3><p>When testing non-deterministic code, it's handy to be able to say &quot;I expect these assertions to pass in a certain time&quot;.
Sometimes you can do a Thread.sleep but this is bad as you have to set a timeout that's high enough so that it won't expire prematurely.
Plus it means that your test will sit around even if the code completes quickly. Another common method is to use countdown latches.
KotlinTest provides the <code>Eventually</code> mixin, which gives you the <code>eventually</code> function which will repeatedly test the code until it either passes,
or the timeout is reached. This is perfect for nondeterministic code. For example:</p><pre><code class="language-kotlin">class MyTests : ShouldSpec() {
  init {
    should(&quot;do something&quot;) {
      eventually(5.seconds) {
        // code here that should complete in 5 seconds but takes an non-determistic amount of time.
      }
    }
  }
}
</code></pre><h2><a id="Extensions"></a>Extensions</h2><p>KotlinTest comes with several extension modules which are not part of the main build.</p><h3><a id="Arrow"></a>Arrow</h3><p>The arrow extension module provives assertions for the functional programming library <a href="https://arrow-kt.io/">arrow-kt</a> for types such as <code>Option</code>, <code>Try</code>, and so on.
 To use this library you need to add <code>kotlintest-assertions-arrow</code> to your build.</p><p>Here is an example asserting that an <code>Option</code> variable is a <code>Some</code> with a value <code>&quot;Foo&quot;</code>.</p><pre><code class="language-kotlin">val option: Option&lt;String&gt; = ...
option shouldBe beSome(&quot;foo&quot;)
</code></pre><p>For the full list of arrow matchers <a href="arrow-matchers.md">click here</a>.</p><p>Additionally, the module provides inspectors that work specifically for the <code>NonEmptyList</code> type.
For example, we can test that a set of assertions hold only for a single element in a Nel by using the <code>forOne</code> inspector.</p><pre><code class="language-kotlin">val list = NonEmptyList(2, 4, 6, 7,8)
list.forOne {
  it.shouldBeOdd()
}
</code></pre><p>Other inspectors include <code>forNone</code>, <code>forAll</code>, <code>forExactly(n)</code>, <code>forSome</code> and so on. See the section on <a href="https://github.com/kotlintest/kotlintest/blob/master/doc/reference.md#inspectors">inspectors</a> for more details.</p><h3><a id="Spring"></a>Spring</h3><p>KotlinTest offers a Spring extension that allows you to test code that wires dependencies using Spring.
To use this extension add the <code>kotlintest-extensions-spring</code> module to your test compile path.</p><p>In order to let Spring know which configuration class to use, you must annotate your Spec classes with <code>@ContextConfiguration</code>.
This should point to a class annotated with the Spring <code>@Configuration</code> annotation. Alternatively, you can use <code>@ActiveProfile</code> to
point to a <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html">specific application context file</a>.</p><p>There are two ways to enable spring wiring depending on if you want to use constructor injection, or field injection.</p><h4><a id="Field Injection"></a>Field Injection</h4><p>If you wish to use field injection, then the <code>SpringListener</code> must be registered with any
 Spec that uses spring beans. For example:</p><pre><code class="language-kotlin">@ContextConfiguration(classes = [(TestConfiguration::class)])
class SpringExampleSpec : WordSpec() {

  override fun listeners() = listOf(SpringListener)

  @Autowired
  var bean: MyBean? = null

  init {
    &quot;Spring Extension&quot; should {
      &quot;have wired up the bean&quot; {
        bean shouldNotBe null
      }
    }
  }
}
</code></pre><p>You could add the <code>SpringListener</code> project wide by registering the listener in <a href="#project-config">ProjectConfig</a>.</p><h4><a id="Constructor Injection"></a>Constructor Injection</h4><p>For constructor injection, we use a different implementation called <code>SpringAutowireConstructorExtension</code> which
 must be registered with <a href="#project-config">ProjectConfig</a>. This extension will intercept each call to create a Spec instance
 and will autowire the beans declared in the primary constructor.</p><p>First an example of the project config.</p><pre><code class="language-kotlin">class ProjectConfig : AbstractProjectConfig() {
  override fun extensions(): List&lt;ProjectLevelExtension&gt; = listOf(SpringAutowireConstructorExtension)
}
</code></pre><p>And now an example of a test class which requires a service called <code>UserService</code> in its primary constructor. This service
 class is just a regular spring bean which has been annotated with @Component.</p><pre><code class="language-kotlin">@ContextConfiguration(classes = [(Components::class)])
class SpringAutowiredConstructorTest(service: UserService) : WordSpec() {
  init {
    &quot;SpringListener&quot; should {
      &quot;have autowired the service&quot; {
        service.repository.findUser().name shouldBe &quot;system_user&quot;
      }
    }
  }
}
</code></pre></div>
    </div>
</template>
<template id="index">
    <div class="box">
        Table of Contents
        <div class="content">
            <ul><li><a href="#aaaa">aaaa1</a><ul><li><a href="#hogeojo">hogeojo2</a><ul><li><a href="#sho">sho3</a><ul></ul></li></ul></li></ul></li><li><a href="#1">11</a><ul><li><a href="#2">22</a><ul><li><a href="#3">33</a><ul><li><a href="#4">44</a><ul></ul></li></ul></li></ul></li></ul></li></ul>
        </div>
    </div>
    <div class="content">
        <div><p>Some <em>Markdown</em></p><p><a href="#sho">link</a></p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentScriptType="application/ecmascript" contentStyleType="text/css" height="129px" preserveAspectRatio="none" style="width:156px;height:129px;" version="1.1" viewBox="0 0 156 129" width="156px" zoomAndPan="magnify"><defs><filter height="300%" id="f1gxxj8zi0weeq" width="300%" x="-1" y="-1"><feGaussianBlur result="blurOut" stdDeviation="2.0"/><feColorMatrix in="blurOut" result="blurOut2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 .4 0"/><feOffset dx="4.0" dy="4.0" in="blurOut2" result="blurOut3"/><feBlend in="SourceGraphic" in2="blurOut3" mode="normal"/></filter></defs><g><line style="stroke: #A80036; stroke-width: 1.0; stroke-dasharray: 5.0,5.0;" x1="21" x2="21" y1="39.6094" y2="87.6094"/><line style="stroke: #A80036; stroke-width: 1.0; stroke-dasharray: 5.0,5.0;" x1="57" x2="57" y1="39.6094" y2="87.6094"/><line style="stroke: #A80036; stroke-width: 1.0; stroke-dasharray: 5.0,5.0;" x1="97" x2="97" y1="39.6094" y2="87.6094"/><line style="stroke: #A80036; stroke-width: 1.0; stroke-dasharray: 5.0,5.0;" x1="136" x2="136" y1="39.6094" y2="87.6094"/><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="22" x="8" y="3"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="8" x="15" y="24.5332">a</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="22" x="8" y="86.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="8" x="15" y="108.1426">a</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="22" x="44" y="3"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="8" x="51" y="24.5332">b</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="22" x="44" y="86.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="8" x="51" y="108.1426">b</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="30" x="80" y="3"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="16" x="87" y="24.5332">aa</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="30" x="80" y="86.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="16" x="87" y="108.1426">aa</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="21" x="124" y="3"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="7" x="131" y="24.5332">c</text><rect fill="#FEFECE" filter="url(#f1gxxj8zi0weeq)" height="31.6094" style="stroke: #A80036; stroke-width: 1.5;" width="21" x="124" y="86.6094"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacingAndGlyphs" textLength="7" x="131" y="108.1426">c</text><polygon fill="#A80036" points="45,51.6094,55,55.6094,45,59.6094,49,55.6094" style="stroke: #A80036; stroke-width: 1.0;"/><line style="stroke: #A80036; stroke-width: 1.0;" x1="21" x2="51" y1="55.6094" y2="55.6094"/><polygon fill="#A80036" points="124.5,65.6094,134.5,69.6094,124.5,73.6094,128.5,69.6094" style="stroke: #A80036; stroke-width: 1.0;"/><line style="stroke: #A80036; stroke-width: 1.0;" x1="97" x2="130.5" y1="69.6094" y2="69.6094"/><!--
@startuml
a -> b
aa ->c
@enduml

PlantUML version 1.2018.08(Sun Jun 24 21:31:00 JST 2018)
(GPL source distribution)
Java Runtime: Java(TM) SE Runtime Environment
JVM: Java HotSpot(TM) 64-Bit Server VM
Java Version: 1.8.0_144-b01
Operating System: Windows 10
OS Version: 10.0
Default Encoding: UTF-8
Language: ja
Country: JP
--></g></svg><h1><a id="aaaa"></a>aaaa</h1><p>aaa</p><ul><li>A</li><li>B</li></ul><pre><code class="language-golang">
func main(){
    a:=0
}

</code></pre><table><thead><tr><th>a</th><th>ddd</th></tr></thead><tbody><tr><td>bbb</td><td>aaa</td></tr></tbody></table><h2><a id="hogeojo"></a>hogeojo</h2><h3><a id="sho"></a>sho</h3><p><a href="#sho">link</a></p><ul><li>hoge</li><li>aaa</li><li>bbb</li></ul><h1><a id="1"></a>1</h1><h2><a id="2"></a>2</h2><h3><a id="3"></a>3</h3><h4><a id="4"></a>4</h4></div>
    </div>
</template>

<script type="text/javascript">

function selectPage(id){
    var t = document.querySelector('#'+id);
    var parent=document.querySelector('#injectTarget')

    var clone = document.importNode(t.content, true);
    parent.textContent = null;
    parent.appendChild(clone);
}

document.addEventListener("DOMContentLoaded", function(event) {
    menuItem("index")
});
function menuItem(key){
    selectPage(key)
    let old=document.querySelector(".is-active")
    if(old!=null){
        old.classList.remove("is-active")
    }
    document.querySelector('#menuItem-'+key).classList.add("is-active");

}







































</script>

</body>
</html>

